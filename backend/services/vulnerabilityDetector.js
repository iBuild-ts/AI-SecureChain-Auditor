// Smart Contract Vulnerability Detection Engine
class VulnerabilityDetector {
  constructor() {
    this.vulnerabilityPatterns = {
      reentrancy: {
        patterns: [
          /call\s*\(\s*\)/,
          /\.transfer\s*\(/,
          /\.send\s*\(/
        ],
        severity: 'Critical',
        description: 'Potential reentrancy vulnerability detected',
        remediation: 'Use checks-effects-interactions pattern or reentrancy guards'
      },
      integerOverflow: {
        patterns: [
          /\+\s*=|uint\s+\w+\s*\+/,
          /\*\s*=|uint\s+\w+\s*\*/
        ],
        severity: 'High',
        description: 'Integer overflow/underflow vulnerability',
        remediation: 'Use SafeMath library or Solidity 0.8+ with built-in overflow checks'
      },
      accessControl: {
        patterns: [
          /function\s+\w+\s*\(\s*\)\s*public/,
          /function\s+\w+\s*\(\s*\)\s*external/
        ],
        severity: 'High',
        description: 'Missing access control modifiers',
        remediation: 'Add onlyOwner or role-based access control modifiers'
      },
      gasOptimization: {
        patterns: [
          /for\s*\(\s*uint\s+i\s*=\s*0/,
          /storage\s+\w+\s*=/
        ],
        severity: 'Medium',
        description: 'Gas optimization opportunity',
        remediation: 'Cache storage variables in memory for loops'
      },
      uncheckedCall: {
        patterns: [
          /\.call\s*\(\s*\)\s*;/,
          /\.delegatecall\s*\(\s*\)\s*;/
        ],
        severity: 'High',
        description: 'Unchecked external call',
        remediation: 'Check return value of external calls'
      },
      hardcodedValues: {
        patterns: [
          /address\s*\(\s*0x[a-fA-F0-9]{40}\s*\)/
        ],
        severity: 'Medium',
        description: 'Hardcoded addresses detected',
        remediation: 'Use constructor parameters or state variables for addresses'
      }
    };
  }

  analyzeCode(code) {
    const vulnerabilities = [];
    const lines = code.split('\n');

    Object.entries(this.vulnerabilityPatterns).forEach(([vulnType, config]) => {
      config.patterns.forEach(pattern => {
        lines.forEach((line, index) => {
          if (pattern.test(line)) {
            vulnerabilities.push({
              id: `${vulnType}-${index}`,
              type: vulnType,
              severity: config.severity,
              description: config.description,
              location: `Line ${index + 1}`,
              codeSnippet: line.trim(),
              remediation: config.remediation,
              fixedCode: this.generateFix(vulnType, line)
            });
          }
        });
      });
    });

    return vulnerabilities;
  }

  generateFix(vulnType, originalCode) {
    const fixes = {
      reentrancy: `// Use ReentrancyGuard from OpenZeppelin\nimport "@openzeppelin/contracts/security/ReentrancyGuard.sol";\ncontract MyContract is ReentrancyGuard {\n  function withdraw() public nonReentrant { ... }\n}`,
      integerOverflow: `// Use SafeMath or Solidity 0.8+\nimport "@openzeppelin/contracts/utils/math/SafeMath.js";\nusing SafeMath for uint256;\nuint256 result = amount.add(balance);`,
      accessControl: `// Add access control\nmodifier onlyOwner() {\n  require(msg.sender == owner, "Not authorized");\n  _;\n}\nfunction criticalFunction() public onlyOwner { ... }`,
      gasOptimization: `// Cache storage in memory\nuint256 length = array.length;\nfor (uint256 i = 0; i < length; i++) { ... }`,
      uncheckedCall: `// Check return value\n(bool success, ) = recipient.call{value: amount}("");\nrequire(success, "Call failed");`,
      hardcodedValues: `// Use constructor parameter\nconstructor(address _targetAddress) {\n  targetAddress = _targetAddress;\n}`
    };

    return fixes[vulnType] || 'Review and update code manually';
  }

  calculateRating(vulnerabilities) {
    if (!vulnerabilities || vulnerabilities.length === 0) return 5;

    const severityScore = {
      'Critical': 5,
      'High': 3,
      'Medium': 2,
      'Low': 1
    };

    const totalScore = vulnerabilities.reduce((sum, vuln) => {
      return sum + (severityScore[vuln.severity] || 0);
    }, 0);

    const rating = Math.max(1, 5 - Math.ceil(totalScore / 5));
    return rating;
  }
}

module.exports = new VulnerabilityDetector();
